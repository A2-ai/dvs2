//! DVS configuration types.

use fs_err as fs;
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use crate::HashAlgo;
use crate::MetadataFormat;

/// Metadata about which DVS build generated this configuration.
///
/// This helps with debugging, support, and migration tooling by recording
/// the exact DVS version and commit that created the config file.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct GeneratedBy {
    /// DVS version string (e.g., "0.0.0-9000").
    pub version: String,

    /// Git commit SHA (short hash), if available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,

    /// Tool name (always "dvs" for configs generated by this project).
    #[serde(default = "default_tool_name", skip_serializing_if = "is_default_tool")]
    pub tool: String,
}

fn default_tool_name() -> String {
    "dvs".to_string()
}

fn is_default_tool(s: &String) -> bool {
    s == "dvs"
}

impl GeneratedBy {
    /// Create from the current DVS build.
    pub fn current() -> Self {
        let version_info = crate::version();
        Self {
            version: version_info.version.to_string(),
            commit: version_info.commit.map(String::from),
            tool: "dvs".to_string(),
        }
    }

    /// Create with explicit version info.
    pub fn new(version: impl Into<String>, commit: Option<String>) -> Self {
        Self {
            version: version.into(),
            commit,
            tool: "dvs".to_string(),
        }
    }
}

impl Default for GeneratedBy {
    fn default() -> Self {
        Self::current()
    }
}

/// DVS project configuration.
///
/// Stored in one of:
/// - `dvs.yaml` (with `yaml-config` feature, default)
/// - `dvs.toml` (with `toml-config` feature, without `yaml-config`)
/// - `dvs.json` (fallback when neither feature is enabled)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// Path to the external storage directory.
    pub storage_dir: PathBuf,

    /// Optional file permissions (octal, e.g., 0o664).
    #[serde(default)]
    pub permissions: Option<u32>,

    /// Optional Linux group for stored files.
    #[serde(default)]
    pub group: Option<String>,

    /// Hash algorithm for content addressing.
    /// Defaults to BLAKE3 if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hash_algo: Option<HashAlgo>,

    /// Metadata file format (JSON or TOML).
    /// Defaults to JSON for backward compatibility.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata_format: Option<MetadataFormat>,

    /// Metadata about which DVS build generated this config.
    /// Automatically populated by `dvs init`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generated_by: Option<GeneratedBy>,
}

impl Config {
    /// Create a new configuration.
    ///
    /// Note: This does not set `generated_by`. Use `with_version_info()` to add
    /// version tracking, or let `dvs init` handle it automatically.
    pub fn new(storage_dir: PathBuf, permissions: Option<u32>, group: Option<String>) -> Self {
        Self {
            storage_dir,
            permissions,
            group,
            hash_algo: None,
            metadata_format: None,
            generated_by: None,
        }
    }

    /// Create a new configuration with a specific hash algorithm.
    pub fn with_hash_algo(
        storage_dir: PathBuf,
        permissions: Option<u32>,
        group: Option<String>,
        hash_algo: HashAlgo,
    ) -> Self {
        Self {
            storage_dir,
            permissions,
            group,
            hash_algo: Some(hash_algo),
            metadata_format: None,
            generated_by: None,
        }
    }

    /// Add version tracking info from the current DVS build.
    ///
    /// This records which version and commit created this config,
    /// useful for debugging and migration tooling.
    pub fn with_version_info(mut self) -> Self {
        self.generated_by = Some(GeneratedBy::current());
        self
    }

    /// Get the configured hash algorithm, or the default.
    pub fn hash_algorithm(&self) -> HashAlgo {
        self.hash_algo.unwrap_or_else(crate::helpers::hash::default_algorithm)
    }

    /// Get the configured metadata format, or the default (JSON).
    pub fn metadata_format(&self) -> MetadataFormat {
        self.metadata_format.unwrap_or_default()
    }

    /// Load configuration from a directory.
    ///
    /// Looks for the config file (dvs.yaml, dvs.toml, or dvs.json depending
    /// on feature flags) in the given directory.
    pub fn load_from_dir(dir: &std::path::Path) -> Result<Self, crate::DvsError> {
        let config_path = dir.join(Self::config_filename());
        Self::load(&config_path)
    }

    /// Load configuration from a file.
    ///
    /// Format is determined by feature flags:
    /// - `yaml-config`: YAML format (default)
    /// - `toml-config` (without yaml-config): TOML format
    /// - Neither: JSON format (fallback)
    pub fn load(path: &std::path::Path) -> Result<Self, crate::DvsError> {
        let contents = fs::read_to_string(path)?;

        #[cfg(feature = "yaml-config")]
        {
            let config: Config = serde_yaml::from_str(&contents)?;
            Ok(config)
        }

        #[cfg(all(feature = "toml-config", not(feature = "yaml-config")))]
        {
            let config: Config = toml::from_str(&contents)?;
            Ok(config)
        }

        #[cfg(all(not(feature = "yaml-config"), not(feature = "toml-config")))]
        {
            let config: Config = serde_json::from_str(&contents)?;
            Ok(config)
        }
    }

    /// Save configuration to a file.
    ///
    /// Format is determined by feature flags:
    /// - `yaml-config`: YAML format (default)
    /// - `toml-config` (without yaml-config): TOML format
    /// - Neither: JSON format (fallback)
    pub fn save(&self, path: &std::path::Path) -> Result<(), crate::DvsError> {
        #[cfg(feature = "yaml-config")]
        {
            let yaml = serde_yaml::to_string(self)?;
            fs::write(path, yaml)?;
        }

        #[cfg(all(feature = "toml-config", not(feature = "yaml-config")))]
        {
            let toml_str = toml::to_string_pretty(self)?;
            fs::write(path, toml_str)?;
        }

        #[cfg(all(not(feature = "yaml-config"), not(feature = "toml-config")))]
        {
            let json = serde_json::to_string_pretty(self)?;
            fs::write(path, json)?;
        }

        Ok(())
    }

    /// Get the default config file name.
    ///
    /// Returns filename based on feature flags:
    /// - `yaml-config`: "dvs.yaml" (default)
    /// - `toml-config` (without yaml-config): "dvs.toml"
    /// - Neither: "dvs.json" (fallback)
    pub const fn config_filename() -> &'static str {
        #[cfg(feature = "yaml-config")]
        {
            "dvs.yaml"
        }

        #[cfg(all(feature = "toml-config", not(feature = "yaml-config")))]
        {
            "dvs.toml"
        }

        #[cfg(all(not(feature = "yaml-config"), not(feature = "toml-config")))]
        {
            "dvs.json"
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_new() {
        let config = Config::new(
            PathBuf::from("/storage"),
            Some(0o664),
            Some("data".to_string()),
        );
        assert_eq!(config.storage_dir, PathBuf::from("/storage"));
        assert_eq!(config.permissions, Some(0o664));
        assert_eq!(config.group, Some("data".to_string()));
    }

    #[test]
    fn test_config_roundtrip() {
        let temp_dir = std::env::temp_dir().join("dvs-test-config-roundtrip");
        let _ = fs::create_dir_all(&temp_dir);

        let config_path = temp_dir.join(Config::config_filename());
        let config = Config::new(
            PathBuf::from("/my/storage"),
            Some(0o660),
            Some("mygroup".to_string()),
        );

        // Save
        config.save(&config_path).unwrap();

        // Load
        let loaded = Config::load(&config_path).unwrap();
        assert_eq!(loaded.storage_dir, config.storage_dir);
        assert_eq!(loaded.permissions, config.permissions);
        assert_eq!(loaded.group, config.group);

        // Cleanup
        let _ = fs::remove_dir_all(&temp_dir);
    }

    #[test]
    fn test_config_minimal() {
        let temp_dir = std::env::temp_dir().join("dvs-test-config-minimal");
        let _ = fs::create_dir_all(&temp_dir);

        let config_path = temp_dir.join(Config::config_filename());

        // Write minimal config in appropriate format
        #[cfg(feature = "yaml-config")]
        fs::write(&config_path, "storage_dir: /storage\n").unwrap();

        #[cfg(all(feature = "toml-config", not(feature = "yaml-config")))]
        fs::write(&config_path, "storage_dir = \"/storage\"\n").unwrap();

        #[cfg(all(not(feature = "yaml-config"), not(feature = "toml-config")))]
        fs::write(&config_path, r#"{"storage_dir": "/storage"}"#).unwrap();

        // Load
        let loaded = Config::load(&config_path).unwrap();
        assert_eq!(loaded.storage_dir, PathBuf::from("/storage"));
        assert!(loaded.permissions.is_none());
        assert!(loaded.group.is_none());

        // Cleanup
        let _ = fs::remove_dir_all(&temp_dir);
    }
}
