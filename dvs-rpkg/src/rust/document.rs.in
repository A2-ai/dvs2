use __CARGO_STATICLIB_NAME_PLACEHOLDER__::R_WRAPPERS_DEPS_@PACKAGE_TARNAME_RS_UPPERCASE@ as DEPS;
use __CARGO_STATICLIB_NAME_PLACEHOLDER__::R_WRAPPERS_IMPL_DEPS_@PACKAGE_TARNAME_RS_UPPERCASE@ as IMPL_DEPS;
use __CARGO_STATICLIB_NAME_PLACEHOLDER__::R_WRAPPERS_IMPLS_@PACKAGE_TARNAME_RS_UPPERCASE@ as IMPLS;
use __CARGO_STATICLIB_NAME_PLACEHOLDER__::R_WRAPPERS_PARTS_@PACKAGE_TARNAME_RS_UPPERCASE@ as PARTS;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    use std::io::Write;

    let dep_flat: Vec<&'static str> = DEPS.concat();
    let impl_dep_flat: Vec<&'static str> = IMPL_DEPS.concat();
    let roots: [&[&'static str]; 4] = [PARTS, IMPLS, &dep_flat, &impl_dep_flat];

    let wrapper_path = "@PACKAGE_TARNAME@-wrappers.R";
    let mut f = std::fs::OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(wrapper_path)
        .map_err(|e| format!("failed to open {wrapper_path}: {e}"))?;

    // Write "do not edit" header with lintr guards
    f.write_all(
        b"# ---- AUTO-GENERATED FILE - DO NOT EDIT ----
# This file is generated by the miniextendr proc-macro during package build.
# Any manual changes will be overwritten.
#
# To regenerate: run `devtools::document()` or rebuild the package.
# nolint start
# nocov start

",
    )
    .map_err(|e| format!("failed to write header to {wrapper_path}: {e}"))?;

    // Normalize each fragment first, then dedupe on the normalized string.
    // This ensures semantically identical wrappers differing only by whitespace
    // are correctly deduplicated.
    let mut seen = std::collections::HashSet::<String>::new();
    for group in roots {
        for &s in group {
            let normalized: String = s
                .trim()
                .lines()
                .map(|line| line.strip_prefix("  ").unwrap_or(line))
                .collect::<Vec<_>>()
                .join("\n");
            if seen.insert(normalized.clone()) {
                f.write_all(normalized.as_bytes())
                    .map_err(|e| format!("failed to write wrapper to {wrapper_path}: {e}"))?;
                f.write_all(b"\n\n")
                    .map_err(|e| format!("failed to write wrapper to {wrapper_path}: {e}"))?;
            }
        }
    }

    // Write closing guards
    f.write_all(b"# nocov end\n# nolint end\n")
        .map_err(|e| format!("failed to write footer to {wrapper_path}: {e}"))?;

    Ok(())
}
