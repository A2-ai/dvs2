//! Shared utilities for R class wrapper generation.
//!
//! This module provides abstractions to reduce duplication across the 5 class system
//! generators (Env, R6, S3, S4, S7). Each class system has different R idioms but shares
//! common patterns:
//!
//! - Class-level roxygen documentation
//! - Constructor generation
//! - Instance method iteration with `.Call()` building
//! - Static method handling
//! - Return strategy application
//!
//! ## Architecture
//!
//! ```text
//! ParsedImpl
//!     │
//!     ├─▶ ClassDocBuilder  → roxygen header lines (#' @title, @name, etc.)
//!     │
//!     └─▶ MethodContext[]  → pre-computed method data for each method
//!             │
//!             └─▶ ClassFormatter::format_constructor()
//!             └─▶ ClassFormatter::format_instance_method()
//!             └─▶ ClassFormatter::format_static_method()
//! ```

use crate::miniextendr_impl::{ParsedImpl, ParsedMethod};

/// Pre-computed context for a method, holding all data needed for R wrapper generation.
///
/// This struct captures the common computations performed for every method across all
/// class systems, reducing duplicate code.
pub struct MethodContext<'a> {
    /// Reference to the parsed method
    pub method: &'a ParsedMethod,
    /// The C wrapper identifier string (e.g., "C_Counter__inc")
    pub c_ident: String,
    /// R formals string (e.g., "value, step = 1L")
    pub params: String,
    /// R call args string (e.g., "value, step")
    pub args: String,
}

impl<'a> MethodContext<'a> {
    /// Create a new MethodContext for a method.
    pub fn new(method: &'a ParsedMethod, type_ident: &syn::Ident, label: Option<&str>) -> Self {
        let c_ident = method.c_wrapper_ident(type_ident, label).to_string();
        let params =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        let args = crate::r_wrapper_builder::build_r_call_args_from_sig(&method.sig);
        Self {
            method,
            c_ident,
            params,
            args,
        }
    }

    /// Build the `.Call()` expression for a static/constructor call.
    pub fn static_call(&self) -> String {
        if self.args.is_empty() {
            format!(".Call({}, .call = match.call())", self.c_ident)
        } else {
            format!(
                ".Call({}, .call = match.call(), {})",
                self.c_ident, self.args
            )
        }
    }

    /// Build the `.Call()` expression for an instance method with `self` as ptr.
    ///
    /// The `self_expr` is typically "self", "private$.ptr", "x", "x@ptr", or "x@.ptr".
    pub fn instance_call(&self, self_expr: &str) -> String {
        if self.args.is_empty() {
            format!(
                ".Call({}, .call = match.call(), {})",
                self.c_ident, self_expr
            )
        } else {
            format!(
                ".Call({}, .call = match.call(), {}, {})",
                self.c_ident, self_expr, self.args
            )
        }
    }

    /// Build full R formals for instance methods (prefixing x/self parameter).
    ///
    /// For S3/S4/S7: `"x, <params>, ..."`
    /// For Env/R6: `"<params>"` (self is implicit)
    pub fn instance_formals(&self, add_self_param: bool) -> String {
        if add_self_param {
            if self.params.is_empty() {
                "x, ...".to_string()
            } else {
                format!("x, {}, ...", self.params)
            }
        } else {
            self.params.clone()
        }
    }

    /// Get the generic name (uses override if present).
    pub fn generic_name(&self) -> String {
        self.method
            .method_attrs
            .generic
            .clone()
            .unwrap_or_else(|| self.method.ident.to_string())
    }

    /// Check if this method uses a generic override (for existing generics like print).
    pub fn has_generic_override(&self) -> bool {
        self.method.method_attrs.generic.is_some()
    }

    /// Get custom class suffix if specified.
    ///
    /// This allows double-dispatch patterns like `vec_ptype2.my_class.my_class`
    /// by specifying `#[miniextendr(s3(generic = "vec_ptype2", class = "my_class.my_class"))]`.
    pub fn class_suffix(&self) -> Option<&str> {
        self.method.method_attrs.class.as_deref()
    }

    /// Check if this method uses a custom class suffix.
    pub fn has_class_override(&self) -> bool {
        self.method.method_attrs.class.is_some()
    }
}

/// Builder for class-level roxygen documentation header.
///
/// Generates the common roxygen tags that appear at the start of each class definition:
/// - `@title` (unless user provided)
/// - `@name` (unless user provided)
/// - `@rdname` (unless user provided)
/// - User-provided doc tags
/// - `@source Generated by miniextendr...`
/// - Class-system-specific imports
/// - `@export` (unless user provided)
pub struct ClassDocBuilder<'a> {
    class_name: &'a str,
    type_ident: &'a syn::Ident,
    doc_tags: &'a [String],
    class_system_label: &'static str,
    imports: Option<&'static str>,
}

impl<'a> ClassDocBuilder<'a> {
    /// Create a new ClassDocBuilder.
    pub fn new(
        class_name: &'a str,
        type_ident: &'a syn::Ident,
        doc_tags: &'a [String],
        class_system_label: &'static str,
    ) -> Self {
        Self {
            class_name,
            type_ident,
            doc_tags,
            class_system_label,
            imports: None,
        }
    }

    /// Set R package imports (e.g., "@importFrom R6 R6Class").
    pub fn with_imports(mut self, imports: &'static str) -> Self {
        self.imports = Some(imports);
        self
    }

    /// Build the roxygen lines for the class header.
    pub fn build(&self) -> Vec<String> {
        let has_title = crate::roxygen::has_roxygen_tag(self.doc_tags, "title");
        let has_name = crate::roxygen::has_roxygen_tag(self.doc_tags, "name");
        let has_rdname = crate::roxygen::has_roxygen_tag(self.doc_tags, "rdname");
        let has_export = crate::roxygen::has_roxygen_tag(self.doc_tags, "export");
        let has_no_rd = crate::roxygen::has_roxygen_tag(self.doc_tags, "noRd");
        let has_internal = crate::roxygen::has_roxygen_tag(self.doc_tags, "keywords internal");

        let mut lines = Vec::new();

        if !has_title && !has_no_rd {
            lines.push(format!(
                "#' @title {} {} Class",
                self.class_name, self.class_system_label
            ));
        }
        if !has_name && !has_no_rd {
            lines.push(format!("#' @name {}", self.class_name));
        }
        if !has_rdname && !has_no_rd {
            lines.push(format!("#' @rdname {}", self.class_name));
        }
        crate::roxygen::push_roxygen_tags(&mut lines, self.doc_tags);
        if !has_no_rd {
            lines.push(format!(
                "#' @source Generated by miniextendr from Rust type `{}`",
                self.type_ident
            ));
        }
        if let Some(imports) = self.imports
            && !has_no_rd
        {
            lines.push(format!("#' {}", imports));
        }
        // Don't auto-export if @noRd or @keywords internal is present
        if !has_export && !has_no_rd && !has_internal {
            lines.push("#' @export".to_string());
        }

        lines
    }
}

/// Builder for method-level roxygen documentation.
///
/// Generates roxygen tags for individual methods:
/// - User-provided doc tags
/// - `@name` (unless user provided) - for Class$method style
/// - `@rdname` (unless user provided)
/// - `@source` annotation
pub struct MethodDocBuilder<'a> {
    class_name: &'a str,
    method_name: &'a str,
    type_ident: &'a syn::Ident,
    doc_tags: &'a [String],
    name_prefix: Option<&'a str>,
    r_name_override: Option<String>,
    always_export: bool,
    /// Whether the parent class has @noRd (suppresses method docs too)
    class_has_no_rd: bool,
}

impl<'a> MethodDocBuilder<'a> {
    /// Create a new MethodDocBuilder.
    ///
    /// Note: `always_export` defaults to `false` because methods accessed via `Class$method`
    /// should not be exported directly - only the class env and S3 methods should be exported.
    pub fn new(
        class_name: &'a str,
        method_name: &'a str,
        type_ident: &'a syn::Ident,
        doc_tags: &'a [String],
    ) -> Self {
        Self {
            class_name,
            method_name,
            type_ident,
            doc_tags,
            name_prefix: None,
            r_name_override: None,
            always_export: false,
            class_has_no_rd: false,
        }
    }

    /// Set a prefix for the @name tag (e.g., "$" for "Class$method").
    pub fn with_name_prefix(mut self, prefix: &'a str) -> Self {
        self.name_prefix = Some(prefix);
        self
    }

    /// Override the @name tag with a custom R function name.
    ///
    /// Use this when the R function name differs from the Rust method name
    /// (e.g., for standalone S3/S4/S7 static methods like `s3counter_default_counter`).
    pub fn with_r_name(mut self, r_name: String) -> Self {
        self.r_name_override = Some(r_name);
        self
    }

    /// Set whether to always add @export (default: true).
    #[allow(dead_code)]
    pub fn with_export(mut self, export: bool) -> Self {
        self.always_export = export;
        self
    }

    /// Set whether the parent class has @noRd.
    ///
    /// When true, skips @name, @rdname, @source tags and adds @noRd instead.
    pub fn with_class_no_rd(mut self, class_has_no_rd: bool) -> Self {
        self.class_has_no_rd = class_has_no_rd;
        self
    }

    /// Build the roxygen lines for the method.
    pub fn build(&self) -> Vec<String> {
        let mut lines = Vec::new();

        // If parent class has @noRd, skip all documentation and just add @noRd
        if self.class_has_no_rd {
            lines.push("#' @noRd".to_string());
            return lines;
        }

        if !self.doc_tags.is_empty() {
            crate::roxygen::push_roxygen_tags(&mut lines, self.doc_tags);
        }

        if !crate::roxygen::has_roxygen_tag(self.doc_tags, "name") {
            let name = if let Some(ref r_name) = self.r_name_override {
                r_name.clone()
            } else if let Some(prefix) = self.name_prefix {
                format!("{}{}{}", self.class_name, prefix, self.method_name)
            } else {
                self.method_name.to_string()
            };
            lines.push(format!("#' @name {}", name));
        }

        if !crate::roxygen::has_roxygen_tag(self.doc_tags, "rdname") {
            lines.push(format!("#' @rdname {}", self.class_name));
        }

        lines.push(format!(
            "#' @source Generated by miniextendr from `{}::{}`",
            self.type_ident, self.method_name
        ));

        let has_no_rd = crate::roxygen::has_roxygen_tag(self.doc_tags, "noRd");
        let has_internal = crate::roxygen::has_roxygen_tag(self.doc_tags, "keywords internal");
        // Don't auto-export if @noRd or @keywords internal is present
        if self.always_export
            && !crate::roxygen::has_roxygen_tag(self.doc_tags, "export")
            && !has_no_rd
            && !has_internal
        {
            lines.push("#' @export".to_string());
        }

        lines
    }
}

/// Extension trait for ParsedImpl to iterate over methods as MethodContext.
pub trait ParsedImplExt {
    /// Create a MethodContext for the constructor (if any).
    fn constructor_context(&self) -> Option<MethodContext<'_>>;

    /// Iterate over instance methods as MethodContext.
    fn instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>>;

    /// Iterate over static methods as MethodContext.
    fn static_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>>;

    /// Iterate over public instance methods as MethodContext (for R6).
    fn public_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>>;

    /// Iterate over private instance methods as MethodContext (for R6).
    fn private_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>>;

    /// Iterate over active binding methods as MethodContext (for R6).
    fn active_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>>;
}

impl ParsedImplExt for ParsedImpl {
    fn constructor_context(&self) -> Option<MethodContext<'_>> {
        self.constructor()
            .map(|m| MethodContext::new(m, &self.type_ident, self.label()))
    }

    fn instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>> {
        let type_ident = &self.type_ident;
        let label = self.label();
        self.instance_methods()
            .map(move |m| MethodContext::new(m, type_ident, label))
    }

    fn static_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>> {
        let type_ident = &self.type_ident;
        let label = self.label();
        self.static_methods()
            .map(move |m| MethodContext::new(m, type_ident, label))
    }

    fn public_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>> {
        let type_ident = &self.type_ident;
        let label = self.label();
        self.public_instance_methods()
            .map(move |m| MethodContext::new(m, type_ident, label))
    }

    fn private_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>> {
        let type_ident = &self.type_ident;
        let label = self.label();
        self.private_instance_methods()
            .map(move |m| MethodContext::new(m, type_ident, label))
    }

    fn active_instance_method_contexts(&self) -> impl Iterator<Item = MethodContext<'_>> {
        let type_ident = &self.type_ident;
        let label = self.label();
        self.active_instance_methods()
            .map(move |m| MethodContext::new(m, type_ident, label))
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_method_context_static_call_no_args() {
        // This is a unit test for the static_call method
        // We'd need a mock ParsedMethod to test fully, but we can test the logic
        let call = ".Call(C_Test, .call = match.call())";
        assert!(call.contains(".Call"));
    }
}
