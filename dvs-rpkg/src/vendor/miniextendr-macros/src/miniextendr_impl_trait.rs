//! # `#[miniextendr]` on trait impls - Trait Implementation Registration
//!
//! This module handles `#[miniextendr]` applied to trait implementations,
//! generating the vtable static for cross-package trait dispatch, plus optional
//! R-callable wrappers for direct method access.
//!
//! ## Overview
//!
//! When `#[miniextendr]` is applied to an `impl Trait for Type` block, it:
//!
//! 1. **Detects the trait** from the impl syntax (no attribute args needed)
//! 2. **Generates vtable static** using the trait's `__<trait>_build_vtable` function
//! 3. **Generates C wrappers** for each trait method (for R `.Call` access)
//! 4. **Generates R wrapper code** for the trait methods
//! 5. **Passes through** the original impl block unchanged
//!
//! ## Usage
//!
//! ```ignore
//! use miniextendr_api::miniextendr;
//!
//! // The trait must have been defined with #[miniextendr]
//! // which generates __counter_build_vtable::<T>()
//!
//! struct MyCounter { value: i32 }
//!
//! #[miniextendr]
//! impl Counter for MyCounter {
//!     fn value(&self) -> i32 {
//!         self.value
//!     }
//!     fn increment(&mut self) {
//!         self.value += 1;
//!     }
//!     fn add(&mut self, n: i32) {
//!         self.value += n;
//!     }
//! }
//! ```
//!
//! Generates (conceptually):
//!
//! ```ignore
//! // Original impl block (passed through)
//! impl Counter for MyCounter {
//!     fn value(&self) -> i32 { self.value }
//!     fn increment(&mut self) { self.value += 1; }
//!     fn add(&mut self, n: i32) { self.value += n; }
//! }
//!
//! // Generated vtable static
//! pub static __VTABLE_COUNTER_FOR_MYCOUNTER: CounterVTable =
//!     __counter_build_vtable::<MyCounter>();
//! ```
//!
//! ## How It Works
//!
//! 1. Parse `impl Trait for Type` to extract trait path and concrete type
//! 2. Generate vtable static name: `__VTABLE_{TRAIT}_FOR_{TYPE}`
//! 3. Generate vtable builder call: `__{trait}_build_vtable::<Type>()`
//! 4. The vtable builder was generated by `#[miniextendr]` on the trait
//!
//! ## Trait Detection
//!
//! The macro reads the trait directly from the impl syntax:
//!
//! ```ignore
//! #[miniextendr]
//! impl path::to::Counter for MyType { ... }
//! //   ^^^^^^^^^^^^^^^^^ detected automatically
//! ```
//!
//! No extra arguments are needed; the trait path is explicit in the impl syntax.
//!
//! ## Name Generation
//!
//! - **Vtable static**: `__VTABLE_{TRAIT}_FOR_{TYPE}` (uppercase, underscores)
//! - **Vtable builder**: `__{trait}_build_vtable` (lowercase)
//!
//! For `impl foo::Counter for my_mod::MyType`:
//! - Static: `__VTABLE_COUNTER_FOR_MYTYPE`
//! - Builder call: `foo::__counter_build_vtable::<my_mod::MyType>()`
//!
//! ## Integration with ExternalPtr / TypedExternal
//!
//! The generated vtable static is referenced by the wrapper emitted from
//! `miniextendr_module! { impl Trait for Type; }`.
//!
//! ```ignore
//! #[derive(ExternalPtr)]
//! struct MyCounter { value: i32 }
//!
//! miniextendr_module! {
//!     mod mypkg;
//!     impl Counter for MyCounter;
//! }
//! ```
//!
//! `ExternalPtr<T>` provides the type identity for the external pointer,
//! while the module entry wires trait dispatch.
//!
//! ## Thread Safety
//!
//! The generated vtable is a static constant, safe to access from any thread.
//! Trait shims now mirror inherent impls: instance methods stay on the main
//! thread, while static trait methods run on the worker thread unless
//! `main_thread` is explicitly requested.

use proc_macro2::TokenStream;
use quote::format_ident;
use syn::ItemImpl;

use crate::miniextendr_impl::{ClassSystem, ImplAttrs};

/// Parsed method from a trait impl block.
#[derive(Debug)]
struct TraitMethod {
    /// Method identifier
    ident: syn::Ident,
    /// Method signature (including self)
    sig: syn::Signature,
    /// Does this method have a receiver (&self, &mut self, self)?
    has_self: bool,
    /// Is this &mut self (vs &self)? Only meaningful if has_self is true.
    is_mut: bool,
    /// Opt-in flags controlling thread strategy.
    /// Note: This field is currently unused since WorkerThread is the default for static methods.
    /// Kept for explicitness and potential future use (e.g., forcing main thread static methods).
    #[allow(dead_code)]
    worker: bool,
    unsafe_main_thread: bool,
    /// Enable automatic type coercion for all parameters
    coerce: bool,
    /// Check for R user interrupts before calling the method
    check_interrupt: bool,
    /// Enable RNG state management (GetRNGstate/PutRNGstate)
    rng: bool,
    /// Return `Result<T, E>` to R without unwrapping.
    unwrap_in_r: bool,
    /// Parameter default values from `#[miniextendr(defaults(param = "value", ...))]`
    param_defaults: std::collections::HashMap<String, String>,
    /// Roxygen @param tags extracted from method doc comments
    param_tags: Vec<String>,
}

impl TraitMethod {
    /// C wrapper identifier: `C_{Type}__{Trait}__{method}`
    fn c_wrapper_ident(&self, type_ident: &syn::Ident, trait_name: &syn::Ident) -> syn::Ident {
        format_ident!("C_{}__{}__{}", type_ident, trait_name, self.ident)
    }

    /// R_CallMethodDef identifier
    fn call_method_def_ident(
        &self,
        type_ident: &syn::Ident,
        trait_name: &syn::Ident,
    ) -> syn::Ident {
        format_ident!(
            "call_method_def_{}__{}_{}",
            type_ident,
            trait_name,
            self.ident
        )
    }
}

/// Parsed const from a trait impl block.
#[derive(Debug)]
struct TraitConst {
    /// Const identifier
    ident: syn::Ident,
    /// Const type
    ty: syn::Type,
}

impl TraitConst {
    /// C wrapper identifier: `C_{Type}__{Trait}__{CONST}`
    fn c_wrapper_ident(&self, type_ident: &syn::Ident, trait_name: &syn::Ident) -> syn::Ident {
        format_ident!("C_{}__{}__{}", type_ident, trait_name, self.ident)
    }

    /// R_CallMethodDef identifier
    fn call_method_def_ident(
        &self,
        type_ident: &syn::Ident,
        trait_name: &syn::Ident,
    ) -> syn::Ident {
        format_ident!(
            "call_method_def_{}__{}_{}",
            type_ident,
            trait_name,
            self.ident
        )
    }
}

/// Expand `#[miniextendr]` applied to a trait implementation.
///
/// # Arguments
///
/// * `attr` - Attribute arguments (currently unused)
/// * `item` - The impl block token stream
///
/// # Returns
///
/// Expanded token stream containing:
/// - Original impl block
/// - Vtable static constant
///
/// # Errors
///
/// Returns a compile error if:
/// - Not applied to a trait impl (`impl Trait for Type`)
/// - Applied to an inherent impl (`impl Type`)
pub fn expand_miniextendr_impl_trait(
    attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    // Parse class system from attribute (defaults to Env if empty)
    let impl_attrs: ImplAttrs = syn::parse_macro_input!(attr as ImplAttrs);
    let impl_item = syn::parse_macro_input!(item as ItemImpl);

    // Validate: must be a trait impl, not inherent impl
    let (trait_path, concrete_type) = match extract_trait_and_type(&impl_item) {
        Ok(result) => result,
        Err(e) => return e.into_compile_error().into(),
    };

    // Generate the vtable static and R wrappers
    let expanded = generate_vtable_static(
        &impl_item,
        &trait_path,
        &concrete_type,
        impl_attrs.class_system,
    );

    expanded.into()
}

/// Extract the trait path and concrete type from an impl block.
///
/// For `impl path::Trait for concrete::Type`, returns:
/// - trait_path: `path::Trait`
/// - concrete_type: `concrete::Type`
fn extract_trait_and_type(impl_item: &ItemImpl) -> syn::Result<(syn::Path, syn::Type)> {
    // Check for trait impl
    let (_, trait_path, _) = impl_item.trait_.as_ref().ok_or_else(|| {
        syn::Error::new_spanned(
            impl_item,
            "#[miniextendr] must be applied to a trait implementation (impl Trait for Type), \
             not an inherent impl (impl Type)",
        )
    })?;

    let concrete_type = (*impl_item.self_ty).clone();

    Ok((trait_path.clone(), concrete_type))
}

/// Generate the vtable static and R-callable wrappers for a trait implementation.
fn generate_vtable_static(
    impl_item: &ItemImpl,
    trait_path: &syn::Path,
    concrete_type: &syn::Type,
    class_system: ClassSystem,
) -> TokenStream {
    // Extract trait name for naming
    let Some(trait_name) = trait_path.segments.last().map(|s| &s.ident) else {
        return syn::Error::new_spanned(trait_path, "trait path must have at least one segment")
            .into_compile_error();
    };

    // Extract type identifier (for simple types)
    let type_ident = match concrete_type {
        syn::Type::Path(type_path) => {
            let Some(last_seg) = type_path.path.segments.last() else {
                return syn::Error::new_spanned(
                    concrete_type,
                    "type path must have at least one segment",
                )
                .into_compile_error();
            };
            last_seg.ident.clone()
        }
        _ => format_ident!("Unknown"),
    };

    // Extract type name for naming (simplified - handles Path types)
    let type_name_str = type_to_uppercase_name(concrete_type);
    let trait_name_upper = trait_name.to_string().to_uppercase();
    let trait_name_lower = trait_name.to_string().to_lowercase();

    // Generate names
    let vtable_static_name = format_ident!("__VTABLE_{}_FOR_{}", trait_name_upper, type_name_str);
    let vtable_type_name = format_ident!("{}VTable", trait_name);

    // Build path to vtable builder function
    // If trait is `foo::Counter`, builder is `foo::__counter_build_vtable`
    let mut builder_path = trait_path.clone();
    if let Some(last) = builder_path.segments.last_mut() {
        last.ident = format_ident!("__{}_build_vtable", trait_name_lower);
    }

    // Build the vtable type path (same module as trait)
    let mut vtable_type_path = trait_path.clone();
    if let Some(last) = vtable_type_path.segments.last_mut() {
        last.ident = vtable_type_name.clone();
    }

    // Parse methods and consts from the impl block
    let methods = extract_methods(impl_item);
    let consts = extract_consts(impl_item);

    // Generate C wrappers and call defs for each method
    let method_c_wrappers: Vec<TokenStream> = methods
        .iter()
        .map(|m| generate_trait_method_c_wrapper(m, &type_ident, trait_name, trait_path))
        .collect();

    // Generate C wrappers for consts
    let const_c_wrappers: Vec<TokenStream> = consts
        .iter()
        .map(|c| generate_trait_const_c_wrapper(c, &type_ident, trait_name, trait_path))
        .collect();

    // Combine C wrappers
    let c_wrappers: Vec<TokenStream> = method_c_wrappers
        .into_iter()
        .chain(const_c_wrappers)
        .collect();

    // Generate R wrapper code string based on class system
    let r_wrapper_string =
        generate_trait_r_wrapper(&type_ident, trait_name, &methods, &consts, class_system);

    // Generate constant names for module registration
    let call_defs_const = format_ident!(
        "{}_{}_CALL_DEFS",
        type_ident.to_string().to_uppercase(),
        trait_name_upper
    );
    let r_wrappers_const = format_ident!(
        "R_WRAPPERS_{}_{}_IMPL",
        type_ident.to_string().to_uppercase(),
        trait_name_upper
    );

    // Collect call method def identifiers (methods + consts)
    let method_call_def_idents: Vec<syn::Ident> = methods
        .iter()
        .map(|m| m.call_method_def_ident(&type_ident, trait_name))
        .collect();
    let const_call_def_idents: Vec<syn::Ident> = consts
        .iter()
        .map(|c| c.call_method_def_ident(&type_ident, trait_name))
        .collect();
    let call_def_idents: Vec<syn::Ident> = method_call_def_idents
        .into_iter()
        .chain(const_call_def_idents)
        .collect();
    let call_defs_len = call_def_idents.len();
    let call_defs_len_lit =
        syn::LitInt::new(&call_defs_len.to_string(), proc_macro2::Span::call_site());

    // Format R wrapper as raw string literal
    let r_wrapper_str: TokenStream = {
        use std::str::FromStr;
        let indented = r_wrapper_string.replace('\n', "\n    ");
        let raw = format!("r#\"\n    {}\n\"#", indented);
        TokenStream::from_str(&raw).expect("valid raw string literal")
    };

    quote::quote! {
        // Pass through the original impl block
        #impl_item

        #[doc = concat!(
            "Vtable for `",
            stringify!(#concrete_type),
            "` implementing `",
            stringify!(#trait_path),
            "`."
        )]
        #[doc = "Generated by `#[miniextendr]` on the trait impl block."]
        #[doc(hidden)]
        static #vtable_static_name: #vtable_type_path =
            #builder_path::<#concrete_type>();

        // C wrappers and call method defs for trait methods
        #(#c_wrappers)*

        #[doc = concat!(
            "R wrapper code for `",
            stringify!(#type_ident),
            "` implementing `",
            stringify!(#trait_name),
            "`."
        )]
        #[doc(hidden)]
        const #r_wrappers_const: &str = #r_wrapper_str;

        #[doc = concat!(
            "Call method def array for `",
            stringify!(#type_ident),
            "` implementing `",
            stringify!(#trait_name),
            "`."
        )]
        #[doc(hidden)]
        const #call_defs_const: [::miniextendr_api::ffi::R_CallMethodDef; #call_defs_len_lit] =
            [#(#call_def_idents),*];
    }
}

/// Extract methods from a trait impl block.
fn extract_methods(impl_item: &ItemImpl) -> Vec<TraitMethod> {
    impl_item
        .items
        .iter()
        .filter_map(|item| {
            if let syn::ImplItem::Fn(method) = item {
                // Check receiver type
                let (has_self, is_mut) = method.sig.inputs.first().map_or((false, false), |arg| {
                    if let syn::FnArg::Receiver(r) = arg {
                        (true, r.mutability.is_some())
                    } else {
                        (false, false)
                    }
                });
                let attrs = parse_trait_method_attrs(&method.attrs);

                // Extract @param tags from method doc comments
                let all_tags = crate::roxygen::roxygen_tags_from_attrs(&method.attrs);
                let param_tags: Vec<String> = all_tags
                    .into_iter()
                    .filter(|tag| tag.starts_with("@param"))
                    .collect();

                Some(TraitMethod {
                    ident: method.sig.ident.clone(),
                    sig: method.sig.clone(),
                    has_self,
                    is_mut,
                    worker: attrs.worker,
                    unsafe_main_thread: attrs.unsafe_main_thread,
                    coerce: attrs.coerce,
                    check_interrupt: attrs.check_interrupt,
                    rng: attrs.rng,
                    unwrap_in_r: attrs.unwrap_in_r,
                    param_defaults: attrs.defaults,
                    param_tags,
                })
            } else {
                None
            }
        })
        .collect()
}

/// Parsed attributes for a trait method.
struct TraitMethodAttrs {
    worker: bool,
    unsafe_main_thread: bool,
    coerce: bool,
    check_interrupt: bool,
    rng: bool,
    unwrap_in_r: bool,
    defaults: std::collections::HashMap<String, String>,
}

/// Parse method attributes (worker, main_thread, coerce, defaults).
///
/// Accepts both nested class-system style (e.g., #[miniextendr(env(worker))])
/// and flat style (#[miniextendr(worker)]).
fn parse_trait_method_attrs(attrs: &[syn::Attribute]) -> TraitMethodAttrs {
    let mut worker = false;
    let mut unsafe_main_thread = false;
    let mut coerce = false;
    let mut check_interrupt = false;
    let mut rng = false;
    let mut unwrap_in_r = false;
    let mut defaults = std::collections::HashMap::new();

    for attr in attrs {
        if !attr.path().is_ident("miniextendr") {
            continue;
        }

        let _ = attr.parse_nested_meta(|meta| {
            let is_class_meta = meta.path.is_ident("env")
                || meta.path.is_ident("r6")
                || meta.path.is_ident("s7")
                || meta.path.is_ident("s3")
                || meta.path.is_ident("s4");

            if is_class_meta {
                meta.parse_nested_meta(|inner| {
                    if inner.path.is_ident("worker") {
                        worker = true;
                    } else if inner.path.is_ident("main_thread") {
                        unsafe_main_thread = true;
                    } else if inner.path.is_ident("coerce") {
                        coerce = true;
                    } else if inner.path.is_ident("check_interrupt") {
                        check_interrupt = true;
                    } else if inner.path.is_ident("unwrap_in_r") {
                        unwrap_in_r = true;
                    }
                    // Note: rng is NOT supported nested (env(rng)) - use #[miniextendr(rng)] instead
                    Ok(())
                })?;
            } else if meta.path.is_ident("worker") {
                worker = true;
            } else if meta.path.is_ident("main_thread") {
                unsafe_main_thread = true;
            } else if meta.path.is_ident("coerce") {
                coerce = true;
            } else if meta.path.is_ident("check_interrupt") {
                check_interrupt = true;
            } else if meta.path.is_ident("rng") {
                rng = true;
            } else if meta.path.is_ident("unwrap_in_r") {
                unwrap_in_r = true;
            } else if meta.path.is_ident("defaults") {
                // Parse defaults(param = "value", param2 = "value2", ...)
                meta.parse_nested_meta(|inner| {
                    let param_name = inner
                        .path
                        .get_ident()
                        .map(|i| i.to_string())
                        .unwrap_or_default();
                    let value: syn::LitStr = inner.value()?.parse()?;
                    defaults.insert(param_name, value.value());
                    Ok(())
                })?;
            }
            Ok(())
        });
    }

    TraitMethodAttrs {
        worker,
        unsafe_main_thread,
        coerce,
        check_interrupt,
        rng,
        unwrap_in_r,
        defaults,
    }
}

/// Extract const items from a trait impl block.
fn extract_consts(impl_item: &ItemImpl) -> Vec<TraitConst> {
    impl_item
        .items
        .iter()
        .filter_map(|item| {
            if let syn::ImplItem::Const(const_item) = item {
                Some(TraitConst {
                    ident: const_item.ident.clone(),
                    ty: const_item.ty.clone(),
                })
            } else {
                None
            }
        })
        .collect()
}

/// Generate a C wrapper for a trait method.
fn generate_trait_method_c_wrapper(
    method: &TraitMethod,
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    trait_path: &syn::Path,
) -> TokenStream {
    use crate::c_wrapper_builder::{CWrapperContext, ReturnHandling, ThreadStrategy};

    let method_ident = &method.ident;
    let c_ident = method.c_wrapper_ident(type_ident, trait_name);
    let call_method_def_ident = method.call_method_def_ident(type_ident, trait_name);

    // Thread strategy: instance methods stay on main thread; static methods default to worker
    // Note: `worker` flag is currently redundant since WorkerThread is already the default
    // for static methods. It's kept for explicitness and potential future use.
    let thread_strategy = if method.has_self || method.unsafe_main_thread {
        ThreadStrategy::MainThread
    } else {
        // Static methods use worker thread (method.worker flag is the default behavior)
        ThreadStrategy::WorkerThread
    };

    // Build rust argument names from the signature (excluding self)
    let rust_args: Vec<syn::Ident> = method
        .sig
        .inputs
        .iter()
        .filter_map(|arg| {
            if let syn::FnArg::Typed(pt) = arg {
                if let syn::Pat::Ident(pat_ident) = pt.pat.as_ref() {
                    Some(pat_ident.ident.clone())
                } else {
                    None
                }
            } else {
                None
            }
        })
        .collect();

    // Filter inputs to exclude the receiver (builder handles self separately with has_self())
    let filtered_inputs: syn::punctuated::Punctuated<syn::FnArg, syn::Token![,]> = method
        .sig
        .inputs
        .iter()
        .filter(|arg| !matches!(arg, syn::FnArg::Receiver(_)))
        .cloned()
        .collect();

    // Determine return handling
    let return_handling = if method.unwrap_in_r && output_is_result(&method.sig.output) {
        ReturnHandling::IntoR
    } else {
        crate::c_wrapper_builder::detect_return_handling(&method.sig.output)
    };

    // Generate R wrapper const name (not actually used but needed by builder)
    let r_wrappers_const = format_ident!(
        "R_WRAPPERS_{}_{}_IMPL",
        type_ident.to_string().to_uppercase(),
        trait_name.to_string().to_uppercase()
    );

    // Build the wrapper using the builder infrastructure
    // Use custom call_method_def_ident to avoid collisions with inherent impl methods
    let mut builder = CWrapperContext::builder(method_ident.clone(), c_ident)
        .r_wrapper_const(r_wrappers_const)
        .inputs(filtered_inputs)
        .output(method.sig.output.clone())
        .thread_strategy(thread_strategy)
        .return_handling(return_handling)
        .type_context(type_ident.clone())
        .call_method_def_ident(call_method_def_ident);

    if method.has_self {
        // Instance method: generate self extraction and call with self_ref
        let trait_method_name = format!("{}::{}()", trait_name, method_ident);
        let self_extraction = if method.is_mut {
            quote::quote! {
                let mut self_ptr = unsafe {
                    ::miniextendr_api::externalptr::ErasedExternalPtr::from_sexp(self_sexp)
                };
                let self_ref = self_ptr.downcast_mut::<#type_ident>()
                    .unwrap_or_else(|| panic!(
                        "type mismatch in {}: expected ExternalPtr<{}>, got different type. \
                         This can happen if you pass an object of a different type to a trait method.",
                        #trait_method_name,
                        stringify!(#type_ident)
                    ));
            }
        } else {
            quote::quote! {
                let self_ptr = unsafe {
                    ::miniextendr_api::externalptr::ErasedExternalPtr::from_sexp(self_sexp)
                };
                let self_ref = self_ptr.downcast_ref::<#type_ident>()
                    .unwrap_or_else(|| panic!(
                        "type mismatch in {}: expected ExternalPtr<{}>, got different type. \
                         This can happen if you pass an object of a different type to a trait method.",
                        #trait_method_name,
                        stringify!(#type_ident)
                    ));
            }
        };

        // Call expression with self_ref
        let call_expr = quote::quote! {
            #trait_path::#method_ident(self_ref, #(#rust_args),*)
        };

        builder = builder
            .pre_call(vec![self_extraction])
            .call_expr(call_expr)
            .has_self();
    } else {
        // Static method: call directly without self
        let call_expr = quote::quote! {
            <#type_ident as #trait_path>::#method_ident(#(#rust_args),*)
        };

        builder = builder.call_expr(call_expr);
    }

    // Apply coerce_all if the method has #[miniextendr(coerce)]
    if method.coerce {
        builder = builder.coerce_all();
    }

    // Apply check_interrupt if the method has #[miniextendr(check_interrupt)]
    if method.check_interrupt {
        builder = builder.check_interrupt();
    }

    // Apply rng if the method has #[miniextendr(rng)]
    if method.rng {
        builder = builder.rng();
    }

    // The builder generates both the C wrapper and the R_CallMethodDef
    builder.build().generate()
}

fn output_is_result(output: &syn::ReturnType) -> bool {
    match output {
        syn::ReturnType::Type(_, ty) => matches!(
            ty.as_ref(),
            syn::Type::Path(p)
                if p.path
                    .segments
                    .last()
                    .map(|s| s.ident == "Result")
                    .unwrap_or(false)
        ),
        syn::ReturnType::Default => false,
    }
}

/// Generate a C wrapper for a trait const.
fn generate_trait_const_c_wrapper(
    trait_const: &TraitConst,
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    trait_path: &syn::Path,
) -> TokenStream {
    use crate::c_wrapper_builder::{CWrapperContext, ThreadStrategy};

    let const_ident = &trait_const.ident;
    let c_ident = trait_const.c_wrapper_ident(type_ident, trait_name);
    let call_method_def_ident = trait_const.call_method_def_ident(type_ident, trait_name);
    let const_ty = &trait_const.ty;

    // Generate R wrapper const name
    let r_wrappers_const = format_ident!(
        "R_WRAPPERS_{}_{}_IMPL",
        type_ident.to_string().to_uppercase(),
        trait_name.to_string().to_uppercase()
    );

    // Build the call expression to access the const
    let call_expr = quote::quote! {
        <#type_ident as #trait_path>::#const_ident
    };

    // Determine return type handling - we need to convert the const to SEXP
    // The return type is `-> Type` not just `Type`
    let return_type: syn::ReturnType = syn::parse_quote!(-> #const_ty);
    let return_handling = crate::c_wrapper_builder::detect_return_handling(&return_type);

    // Build wrapper - no inputs, just returns the const value
    let builder = CWrapperContext::builder(const_ident.clone(), c_ident)
        .r_wrapper_const(r_wrappers_const)
        .inputs(Default::default()) // no inputs
        .output(return_type)
        .call_expr(call_expr)
        .thread_strategy(ThreadStrategy::MainThread)
        .return_handling(return_handling)
        .type_context(type_ident.clone())
        .call_method_def_ident(call_method_def_ident);

    builder.build().generate()
}

/// Generate R wrapper code for trait methods and consts (dispatch by class system).
fn generate_trait_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
    class_system: ClassSystem,
) -> String {
    match class_system {
        ClassSystem::Env => generate_trait_env_r_wrapper(type_ident, trait_name, methods, consts),
        ClassSystem::S3 => generate_trait_s3_r_wrapper(type_ident, trait_name, methods, consts),
        ClassSystem::S4 => generate_trait_s4_r_wrapper(type_ident, trait_name, methods, consts),
        ClassSystem::S7 => generate_trait_s7_r_wrapper(type_ident, trait_name, methods, consts),
        ClassSystem::R6 => generate_trait_r6_r_wrapper(type_ident, trait_name, methods, consts),
        // vctrs uses S3 under the hood, so use the S3 trait wrapper
        ClassSystem::Vctrs => generate_trait_s3_r_wrapper(type_ident, trait_name, methods, consts),
    }
}

/// Generate Env-style R wrapper code (Type$Trait$method).
fn generate_trait_env_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
) -> String {
    use crate::r_wrapper_builder::{DotCallBuilder, RoxygenBuilder};

    let mut lines = Vec::new();
    let type_str = type_ident.to_string();
    let trait_str = trait_name.to_string();

    // Header comment
    lines.push(format!(
        "# Trait methods and consts for {} implementing {}",
        type_ident, trait_name
    ));
    lines.push(format!(
        "# Generated by #[miniextendr] impl {} for {}",
        trait_name, type_ident
    ));
    lines.push(String::new());

    // Create trait namespace environment
    lines.push(format!(
        "{}${} <- new.env(parent = emptyenv())",
        type_ident, trait_name
    ));
    lines.push(String::new());

    for method in methods {
        let method_name = &method.ident;
        let method_str = method_name.to_string();

        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);

        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // For instance methods, include 'x' as first parameter
        let function_params = if method.has_self {
            if formals.is_empty() {
                "x".to_string()
            } else {
                format!("x, {}", formals)
            }
        } else {
            formals
        };

        // Build roxygen tags
        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, method_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = if method.has_self {
            DotCallBuilder::new(&c_ident)
                .with_self("x")
                .with_args(&params)
                .build()
        } else {
            DotCallBuilder::new(&c_ident).with_args(&params).build()
        };

        // Generate method wrapper
        lines.push(format!(
            "{}${}${} <- function({}) {{",
            type_ident, trait_name, method_name, function_params
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Generate const wrappers
    for trait_const in consts {
        let const_name = &trait_const.ident;
        let const_str = const_name.to_string();

        // Build roxygen tags
        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, const_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, const_name);
        let call = DotCallBuilder::new(&c_ident).build();

        // Generate const wrapper
        lines.push(format!(
            "{}${}${} <- function() {{",
            type_ident, trait_name, const_name
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    lines.join("\n")
}

/// Generate S3-style R wrapper code (generic + method.Type).
///
/// For `impl Counter for SimpleCounter`, generates:
/// - S3 generic `value(x, ...)` (if not exists)
/// - S3 method `value.SimpleCounter`
fn generate_trait_s3_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
) -> String {
    use crate::r_wrapper_builder::{DotCallBuilder, RoxygenBuilder};

    let mut lines = Vec::new();
    let type_str = type_ident.to_string();
    let trait_str = trait_name.to_string();

    // Header comment
    lines.push(format!(
        "# S3 trait methods for {} implementing {}",
        type_ident, trait_name
    ));
    lines.push(format!(
        "# Generated by #[miniextendr(s3)] impl {} for {}",
        trait_name, type_ident
    ));
    lines.push(String::new());

    // Separate instance methods (S3 dispatch) from static methods (namespace access)
    let instance_methods: Vec<_> = methods.iter().filter(|m| m.has_self).collect();
    let static_methods: Vec<_> = methods.iter().filter(|m| !m.has_self).collect();

    // Generate S3 generics + methods for instance methods
    for method in &instance_methods {
        let method_name = &method.ident;
        let generic_name = method_name.to_string();
        let s3_method_name = format!("{}.{}", generic_name, type_str);

        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // S3 generic roxygen (only create if doesn't exist)
        let generic_roxygen = RoxygenBuilder::new()
            .title(format!("S3 generic for `{}`", generic_name))
            .custom(format!("S3 generic for `{}`", generic_name))
            .name(&generic_name)
            .rdname(&type_str)
            .custom("@param x An object")
            .custom("@param ... Additional arguments passed to methods")
            .source(format!(
                "Generated by miniextendr from `impl {} for {}`",
                trait_name, type_ident
            ))
            .export()
            .build();
        lines.extend(generic_roxygen);

        // S3 generic definition
        lines.push(format!(
            "if (!exists(\"{generic_name}\", mode = \"function\")) {{"
        ));
        lines.push(format!(
            "    {generic_name} <- function(x, ...) UseMethod(\"{generic_name}\")"
        ));
        lines.push("}".to_string());
        lines.push(String::new());

        // S3 method roxygen (include @param tags from method doc comments)
        let mut method_roxygen = RoxygenBuilder::new()
            .rdname(&type_str)
            .export()
            .method(&generic_name, &type_str);
        for tag in &method.param_tags {
            method_roxygen = method_roxygen.custom(tag.clone());
        }
        lines.extend(method_roxygen.build());

        // S3 method: generic.class
        let full_params = if formals.is_empty() {
            "x, ...".to_string()
        } else {
            format!("x, {}, ...", formals)
        };

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident)
            .with_self("x")
            .with_args(&params)
            .build();

        lines.push(format!(
            "{} <- function({}) {{",
            s3_method_name, full_params
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Create trait namespace for static methods and consts BEFORE assigning to it
    if !static_methods.is_empty() || !consts.is_empty() {
        lines.push(format!(
            "{}${} <- new.env(parent = emptyenv())",
            type_ident, trait_name
        ));
        lines.push(String::new());
    }

    // Generate static methods in Type$Trait$ namespace
    for method in &static_methods {
        let method_name = &method.ident;
        let method_str = method_name.to_string();
        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // Static method roxygen
        lines.push(format!(
            "#' Static trait method {}::{}()",
            trait_name, method_name
        ));
        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, method_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident).with_args(&params).build();

        lines.push(format!(
            "{}${}${} <- function({}) {{",
            type_ident, trait_name, method_name, formals
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Generate const wrappers in Type$Trait$ namespace
    for trait_const in consts {
        let const_name = &trait_const.ident;
        let const_str = const_name.to_string();

        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, const_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, const_name);
        let call = DotCallBuilder::new(&c_ident).build();

        lines.push(format!(
            "{}${}${} <- function() {{",
            type_ident, trait_name, const_name
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    lines.join("\n")
}

/// Generate S4-style R wrapper code.
///
/// For `impl Counter for SimpleCounter`, generates:
/// - S4 generic `value(x, ...)` (if not exists)
/// - S4 method `setMethod("value", "SimpleCounter", ...)`
fn generate_trait_s4_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
) -> String {
    use crate::r_wrapper_builder::{DotCallBuilder, RoxygenBuilder};

    let mut lines = Vec::new();
    let type_str = type_ident.to_string();
    let trait_str = trait_name.to_string();

    // Header comment
    lines.push(format!(
        "# S4 trait methods for {} implementing {}",
        type_ident, trait_name
    ));
    lines.push(format!(
        "# Generated by #[miniextendr(s4)] impl {} for {}",
        trait_name, type_ident
    ));
    lines.push(String::new());

    // Register the S3 class for S4 dispatch using setOldClass
    lines.push("#' @importFrom methods setOldClass setGeneric setMethod isGeneric".to_string());
    lines.push(format!("methods::setOldClass(\"{}\")", type_str));
    lines.push(String::new());

    // Separate instance methods from static methods
    let instance_methods: Vec<_> = methods.iter().filter(|m| m.has_self).collect();
    let static_methods: Vec<_> = methods.iter().filter(|m| !m.has_self).collect();

    // Generate S4 generics + methods for instance methods
    for method in &instance_methods {
        let method_name = &method.ident;
        let generic_name = format!("s4_trait_{}_{}", trait_name, method_name);

        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // Build full parameter list (x first, then others, then ...)
        let full_params = if formals.is_empty() {
            "x, ...".to_string()
        } else {
            format!("x, {}, ...", formals)
        };

        // S4 generic roxygen (include @param tags from method doc comments)
        let mut generic_roxygen = RoxygenBuilder::new()
            .custom(format!(
                "S4 generic for trait method `{}::{}`",
                trait_name, method_name
            ))
            .name(&generic_name)
            .rdname(&type_str)
            .source(format!(
                "Generated by miniextendr from `impl {} for {}`",
                trait_name, type_ident
            ))
            .custom(format!("@param x A `{}` object", type_str))
            .custom("@param ... Additional arguments passed to methods");
        for tag in &method.param_tags {
            generic_roxygen = generic_roxygen.custom(tag.clone());
        }
        lines.extend(generic_roxygen.export().build());

        // S4 generic definition
        lines.push(format!(
            "if (!methods::isGeneric(\"{generic_name}\")) methods::setGeneric(\"{generic_name}\", function(x, ...) standardGeneric(\"{generic_name}\"))"
        ));
        lines.push(String::new());

        // S4 method roxygen + definition (include @param tags from method doc comments)
        lines.push(format!("#' @rdname {}", type_str));
        for tag in &method.param_tags {
            lines.push(format!("#' {}", tag));
        }
        lines.push(format!("#' @exportMethod {}", generic_name));

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident)
            .with_self("x")
            .with_args(&params)
            .build();

        lines.push(format!(
            "methods::setMethod(\"{}\", \"{}\", function({}) {{",
            generic_name, type_str, full_params
        ));
        lines.push(format!("    {}", call));
        lines.push("})".to_string());
        lines.push(String::new());
    }

    // Generate static methods as standalone functions
    for method in &static_methods {
        let method_name = &method.ident;
        let fn_name = format!("{}_{}_{}", type_str, trait_str, method_name);
        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // Static method roxygen
        lines.push(format!(
            "#' Static trait method {}::{}() for {}",
            trait_name, method_name, type_str
        ));
        let roxygen = RoxygenBuilder::new()
            .name(&fn_name)
            .rdname(&type_str)
            .export()
            .build();
        lines.extend(roxygen);

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident).with_args(&params).build();

        lines.push(format!("{} <- function({}) {{", fn_name, formals));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Generate const wrappers as standalone functions
    for trait_const in consts {
        let const_name = &trait_const.ident;
        let fn_name = format!("{}_{}_{}", type_str, trait_str, const_name);

        let roxygen = RoxygenBuilder::new()
            .name(&fn_name)
            .rdname(&type_str)
            .export()
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, const_name);
        let call = DotCallBuilder::new(&c_ident).build();

        lines.push(format!("{} <- function() {{", fn_name));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    lines.join("\n")
}

/// Generate S7-style R wrapper code.
///
/// For `impl Counter for SimpleCounter`, generates:
/// - S7 generic `s7_trait_Counter_value` (if not exists)
/// - S7 method `S7::method(s7_trait_Counter_value, SimpleCounter) <- ...`
fn generate_trait_s7_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
) -> String {
    use crate::r_wrapper_builder::{DotCallBuilder, RoxygenBuilder};

    let mut lines = Vec::new();
    let type_str = type_ident.to_string();
    let trait_str = trait_name.to_string();
    let s7_class_var = format!(".s7_class_{}", type_str);

    // Header comment
    lines.push(format!(
        "# S7 trait methods for {} implementing {}",
        type_ident, trait_name
    ));
    lines.push(format!(
        "# Generated by #[miniextendr(s7)] impl {} for {}",
        trait_name, type_ident
    ));
    lines.push(String::new());

    // Create S7 class wrapper for the S3 class
    lines.push("#' @importFrom S7 new_generic method S7_dispatch new_S3_class".to_string());
    lines.push(format!(
        "{} <- S7::new_S3_class(\"{}\")",
        s7_class_var, type_str
    ));
    lines.push(String::new());

    // Separate instance methods from static methods
    let instance_methods: Vec<_> = methods.iter().filter(|m| m.has_self).collect();
    let static_methods: Vec<_> = methods.iter().filter(|m| !m.has_self).collect();

    // Generate S7 generics + methods for instance methods
    for method in &instance_methods {
        let method_name = &method.ident;
        let generic_name = format!("s7_trait_{}_{}", trait_name, method_name);

        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // Build full parameter list (x first, then others, then ...)
        let full_params = if formals.is_empty() {
            "x, ...".to_string()
        } else {
            format!("x, {}, ...", formals)
        };

        // S7 generic roxygen
        // Note: Don't include method-specific @param tags here since S7 methods
        // are assignments and won't appear in \usage, which would cause warnings
        let generic_roxygen = RoxygenBuilder::new()
            .custom(format!(
                "S7 generic for trait method `{}::{}`",
                trait_name, method_name
            ))
            .name(&generic_name)
            .rdname(&type_str)
            .source(format!(
                "Generated by miniextendr from `impl {} for {}`",
                trait_name, type_ident
            ))
            .export()
            .build();
        lines.extend(generic_roxygen);

        // S7 generic definition
        lines.push(format!(
            "if (!exists(\"{generic_name}\", mode = \"function\")) {generic_name} <- S7::new_generic(\"{generic_name}\", \"x\", function(x, ...) S7::S7_dispatch())"
        ));
        lines.push(String::new());

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident)
            .with_self("x")
            .with_args(&params)
            .build();

        // S7 method definition
        lines.push(format!(
            "S7::method({}, {}) <- function({}) {{",
            generic_name, s7_class_var, full_params
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Create trait namespace for static methods and consts
    if !static_methods.is_empty() || !consts.is_empty() {
        lines.push(format!(
            "{}${} <- new.env(parent = emptyenv())",
            type_ident, trait_name
        ));
        lines.push(String::new());
    }

    // Generate static methods in Type$Trait$ namespace
    for method in &static_methods {
        let method_name = &method.ident;
        let method_str = method_name.to_string();
        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        lines.push(format!(
            "#' Static trait method {}::{}()",
            trait_name, method_name
        ));
        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, method_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident).with_args(&params).build();

        lines.push(format!(
            "{}${}${} <- function({}) {{",
            type_ident, trait_name, method_name, formals
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Generate const wrappers in Type$Trait$ namespace
    for trait_const in consts {
        let const_name = &trait_const.ident;
        let const_str = const_name.to_string();

        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, const_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, const_name);
        let call = DotCallBuilder::new(&c_ident).build();

        lines.push(format!(
            "{}${}${} <- function() {{",
            type_ident, trait_name, const_name
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    lines.join("\n")
}

/// Generate R6-style R wrapper code.
///
/// R6 classes are defined monolithically, so trait methods are generated as
/// standalone functions that accept the R6 object and extract its private `.ptr`.
///
/// For `impl Counter for SimpleCounter`, generates:
/// - `r6_trait_Counter_value(x)` function
/// - `r6_trait_Counter_increment(x)` function
/// - etc.
fn generate_trait_r6_r_wrapper(
    type_ident: &syn::Ident,
    trait_name: &syn::Ident,
    methods: &[TraitMethod],
    consts: &[TraitConst],
) -> String {
    use crate::r_wrapper_builder::{DotCallBuilder, RoxygenBuilder};

    let mut lines = Vec::new();
    let type_str = type_ident.to_string();
    let trait_str = trait_name.to_string();

    // Header comment
    lines.push(format!(
        "# R6 trait methods for {} implementing {}",
        type_ident, trait_name
    ));
    lines.push(format!(
        "# Generated by #[miniextendr(r6)] impl {} for {}",
        trait_name, type_ident
    ));
    lines.push("# Note: R6 trait methods are standalone functions".to_string());
    lines.push(String::new());

    // Separate instance methods from static methods
    let instance_methods: Vec<_> = methods.iter().filter(|m| m.has_self).collect();
    let static_methods: Vec<_> = methods.iter().filter(|m| !m.has_self).collect();

    // Generate standalone functions for instance methods
    for method in &instance_methods {
        let method_name = &method.ident;
        let fn_name = format!("r6_trait_{}_{}", trait_name, method_name);

        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        // Build parameter list (x first, then others)
        let full_params = if formals.is_empty() {
            "x".to_string()
        } else {
            format!("x, {}", formals)
        };

        // R6 trait method roxygen (include @param tags from method doc comments)
        let mut roxygen = RoxygenBuilder::new()
            .custom(format!(
                "R6 trait method `{}::{}` for {}",
                trait_name, method_name, type_str
            ))
            .name(&fn_name)
            .rdname(&type_str)
            .source(format!(
                "Generated by miniextendr from `impl {} for {}`",
                trait_name, type_ident
            ))
            .custom(format!("@param x A `{}` object", type_str));
        for tag in &method.param_tags {
            roxygen = roxygen.custom(tag.clone());
        }
        lines.extend(roxygen.export().build());

        // Build .Call() invocation
        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident)
            .with_self("x")
            .with_args(&params)
            .build();

        lines.push(format!("{} <- function({}) {{", fn_name, full_params));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Create trait namespace for static methods and consts
    if !static_methods.is_empty() || !consts.is_empty() {
        lines.push(format!(
            "{}${} <- new.env(parent = emptyenv())",
            type_ident, trait_name
        ));
        lines.push(String::new());
    }

    // Generate static methods in Type$Trait$ namespace
    for method in &static_methods {
        let method_name = &method.ident;
        let method_str = method_name.to_string();
        // Build R formals with defaults applied
        let formals =
            crate::r_wrapper_builder::build_r_formals_from_sig(&method.sig, &method.param_defaults);
        // Collect param names for .Call() (without defaults)
        let params =
            crate::r_wrapper_builder::collect_param_idents(&method.sig.inputs, false, true);

        lines.push(format!(
            "#' Static trait method {}::{}()",
            trait_name, method_name
        ));
        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, method_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, method_name);
        let call = DotCallBuilder::new(&c_ident).with_args(&params).build();

        lines.push(format!(
            "{}${}${} <- function({}) {{",
            type_ident, trait_name, method_name, formals
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    // Generate const wrappers in Type$Trait$ namespace
    for trait_const in consts {
        let const_name = &trait_const.ident;
        let const_str = const_name.to_string();

        let roxygen = RoxygenBuilder::new()
            .name(format!("{}${}${}", type_str, trait_str, const_str))
            .rdname(&type_str)
            .build();
        lines.extend(roxygen);

        let c_ident = format!("C_{}__{}__{}", type_ident, trait_name, const_name);
        let call = DotCallBuilder::new(&c_ident).build();

        lines.push(format!(
            "{}${}${} <- function() {{",
            type_ident, trait_name, const_name
        ));
        lines.push(format!("    {}", call));
        lines.push("}".to_string());
        lines.push(String::new());
    }

    lines.join("\n")
}

/// Convert a type to an uppercase identifier-safe name.
///
/// Examples:
/// - `MyType`  `MYTYPE`
/// - `path::to::MyType`  `MYTYPE` (uses last segment)
/// - `MyType<T>`  `MYTYPE` (strips generics)
fn type_to_uppercase_name(ty: &syn::Type) -> String {
    match ty {
        syn::Type::Path(type_path) => {
            // Use last segment, strip generics
            type_path
                .path
                .segments
                .last()
                .map(|s| s.ident.to_string().to_uppercase())
                .unwrap_or_else(|| "UNKNOWN".to_string())
        }
        _ => "UNKNOWN".to_string(),
    }
}

#[cfg(test)]
mod tests;
