use super::*;

fn parse_inputs(s: &str) -> syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma> {
    let signature: syn::Signature = syn::parse_str(&format!("fn test({})", s)).unwrap();
    signature.inputs
}

#[test]
fn test_normalize_arg_ident() {
    // Leading underscores are stripped
    let ident = syn::Ident::new("_x", proc_macro2::Span::call_site());
    assert_eq!(normalize_r_arg_ident(&ident).to_string(), "x");

    let ident = syn::Ident::new("__private", proc_macro2::Span::call_site());
    assert_eq!(normalize_r_arg_ident(&ident).to_string(), "private");

    let ident = syn::Ident::new("value", proc_macro2::Span::call_site());
    assert_eq!(normalize_r_arg_ident(&ident).to_string(), "value");
}

#[test]
fn test_basic_formals() {
    let inputs = parse_inputs("x: i32, y: f64");
    let builder = RArgumentBuilder::new(&inputs);
    assert_eq!(builder.build_formals(), "x, y");
}

#[test]
fn test_unit_type_default() {
    // `_unused` becomes `unused` (underscore stripped), unit type gets NULL default
    let inputs = parse_inputs("x: i32, _unused: ()");
    let builder = RArgumentBuilder::new(&inputs);
    assert_eq!(builder.build_formals(), "x, unused = NULL");
}

#[test]
fn test_dots() {
    let inputs = parse_inputs("x: i32, _dots: &Dots");
    let builder = RArgumentBuilder::new(&inputs).with_dots(None);
    assert_eq!(builder.build_formals(), "x, ...");
    assert_eq!(builder.build_call_args(), "x, list(...)");
}

#[test]
fn test_named_dots() {
    // Note: In R, `...` cannot have a name/default in formals.
    // The named_dots is only used on Rust side. R always uses plain `...`
    let inputs = parse_inputs("x: i32, _dots: &Dots");
    let builder = RArgumentBuilder::new(&inputs).with_dots(Some("args".to_string()));
    assert_eq!(builder.build_formals(), "x, ...");
    assert_eq!(builder.build_call_args(), "x, list(...)");
}

#[test]
fn test_skip_first() {
    let inputs = parse_inputs("&self, x: i32, y: f64");
    let builder = RArgumentBuilder::new(&inputs).skip_first();
    assert_eq!(builder.build_formals(), "x, y");
    assert_eq!(builder.build_call_args(), "x, y");
}

#[test]
fn test_underscore_normalization() {
    // Leading underscores are stripped in R (Rust convention for unused params)
    let inputs = parse_inputs("_x: i32, __private: String");
    let builder = RArgumentBuilder::new(&inputs);
    assert_eq!(builder.build_formals(), "x, private");
}

// DotCallBuilder tests
#[test]
fn test_dot_call_no_args() {
    let call = DotCallBuilder::new("C_Counter__new").build();
    assert_eq!(call, ".Call(C_Counter__new, .call = match.call())");
}

#[test]
fn test_dot_call_with_self() {
    let call = DotCallBuilder::new("C_Counter__value")
        .with_self("self")
        .build();
    assert_eq!(call, ".Call(C_Counter__value, .call = match.call(), self)");
}

#[test]
fn test_dot_call_with_self_and_args() {
    let call = DotCallBuilder::new("C_Counter__add")
        .with_self("x")
        .with_args(&["n"])
        .build();
    assert_eq!(call, ".Call(C_Counter__add, .call = match.call(), x, n)");
}

#[test]
fn test_dot_call_static_with_args() {
    let call = DotCallBuilder::new("C_Counter__from_parts")
        .with_args(&["a", "b", "c"])
        .build();
    assert_eq!(
        call,
        ".Call(C_Counter__from_parts, .call = match.call(), a, b, c)"
    );
}

// RoxygenBuilder tests
#[test]
fn test_roxygen_basic() {
    let tags = RoxygenBuilder::new()
        .name("Counter$increment")
        .rdname("Counter")
        .export()
        .build();
    assert_eq!(
        tags,
        vec![
            "#' @name Counter$increment",
            "#' @rdname Counter",
            "#' @export"
        ]
    );
}

#[test]
fn test_roxygen_s3_method() {
    let tags = RoxygenBuilder::new()
        .name("value")
        .source("Generated by miniextendr from `impl Counter for MyType`")
        .method("value", "MyType")
        .export()
        .build();
    assert_eq!(
        tags,
        vec![
            "#' @name value",
            "#' @source Generated by miniextendr from `impl Counter for MyType`",
            "#' @method value MyType",
            "#' @export"
        ]
    );
}

#[test]
fn test_roxygen_s4_method() {
    let tags = RoxygenBuilder::new()
        .name("s4_trait_Counter_value")
        .source("Generated by miniextendr")
        .export_method("s4_trait_Counter_value")
        .build();
    assert_eq!(
        tags,
        vec![
            "#' @name s4_trait_Counter_value",
            "#' @source Generated by miniextendr",
            "#' @exportMethod s4_trait_Counter_value"
        ]
    );
}
