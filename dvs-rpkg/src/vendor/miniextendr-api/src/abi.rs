//! # ABI Types for Cross-Package Trait Dispatch
//!
//! This module defines the stable, C-compatible ABI types used for cross-package
//! trait dispatch in miniextendr. These types enable R packages written with
//! miniextendr to share trait-based interfaces across package boundaries.
//!
//! ## Design Principles
//!
//! 1. **Stability**: All types are `#[repr(C)]` and append-only. Fields are never
//!    removed or reordered, only new fields may be added at the end.
//!
//! 2. **C Compatibility**: Types use only C-compatible primitives to ensure
//!    consistent layout across different Rust versions and compilation units.
//!
//! 3. **Type Safety**: Runtime type checking via [`mx_tag`] ensures type-safe
//!    downcasts even across package boundaries.
//!
//! ## Type Hierarchy
//!
//! ```text
//! mx_erased (type-erased object)
//!     │
//!     └── points to → mx_base_vtable (base vtable)
//!                         │
//!                         ├── drop: fn pointer
//!                         ├── concrete_tag: mx_tag
//!                         └── query: fn pointer → interface vtables
//! ```
//!
//! ## Usage Flow
//!
//! 1. Trait is declared with `#[miniextendr]`, impl uses `#[miniextendr] impl Trait for Type`
//! 2. Type derives `ExternalPtr`
//! 3. `miniextendr_module!` lists `impl Trait for Type;` (generates wrapper + vtables)
//! 4. Constructor returns `*mut mx_erased`
//! 5. `mx_wrap()` wraps pointer in R's EXTPTRSXP
//! 6. Method calls use `mx_query()` to get interface vtable
//! 7. Vtable entry receives `(data, argc, argv)` and returns SEXP
//!
//! ## Example
//!
//! ```ignore
//! // Define trait (generates TAG_FOO, FooVTable, FooView)
//! #[miniextendr]
//! trait Foo {
//!     fn len(&self) -> usize;
//! }
//!
//! // Implement for concrete type
//! #[miniextendr]
//! impl Foo for MyType { /* ... */ }
//!
//! // Register trait impl for wrapper generation
//! miniextendr_module! {
//!     mod mypkg;
//!     impl Foo for MyType;
//! }
//! ```
//!
//! ## Thread Safety
//!
//! All ABI operations are main-thread only. R invokes `.Call` on the main thread,
//! and method shims do not route through `with_r_thread`.

use crate::ffi::SEXP;
use std::os::raw::c_void;

/// Type tag for runtime type identification.
///
/// A 128-bit identifier split into two 64-bit halves for C compatibility.
/// Used to identify concrete types and trait interfaces at runtime.
///
/// ## Generation
///
/// Tags should be generated as compile-time constants, typically using
/// a hash of the fully-qualified type/trait path. The `#[miniextendr]`
/// trait macro and `miniextendr_module!` wrapper generation handle this automatically.
///
/// ## Comparison
///
/// Tags are compared by value equality of both `lo` and `hi` fields.
///
/// ## Layout Guarantee
///
/// This type is `#[repr(C)]` and its layout is frozen. Fields will never
/// be reordered, and new fields will only be appended.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct mx_tag {
    /// Lower 64 bits of the type tag.
    pub lo: u64,
    /// Upper 64 bits of the type tag.
    pub hi: u64,
}

impl mx_tag {
    /// Create a new type tag from two 64-bit values.
    ///
    /// # Arguments
    ///
    /// * `lo` - Lower 64 bits
    /// * `hi` - Upper 64 bits
    ///
    /// # Example
    ///
    /// ```ignore
    /// const MY_TAG: mx_tag = mx_tag::new(0x1234_5678_9abc_def0, 0xfed_cba9_8765_4321);
    /// ```
    #[inline]
    pub const fn new(lo: u64, hi: u64) -> Self {
        Self { lo, hi }
    }
}

/// Method signature for trait vtable entries.
///
/// All trait methods are erased to this uniform signature:
/// - `data`: Pointer to the concrete object data
/// - `argc`: Number of arguments in `argv`
/// - `argv`: Array of SEXP arguments from R
/// - Returns: SEXP result to R
///
/// ## Argument Handling
///
/// The shim generated by `#[miniextendr]` on a trait is responsible for:
/// 1. Checking `argc` matches expected arity
/// 2. Converting each `argv[i]` via [`TryFromSexp`]
/// 3. Calling the actual method
/// 4. Converting the result via [`IntoR`]
/// 5. Catching panics and converting to `r_stop`
///
/// ## Safety
///
/// This function pointer is `unsafe` because:
/// - `data` must point to valid, properly-aligned data of the expected type
/// - `argv` must point to `argc` valid SEXP values
/// - Must be called on R's main thread
///
/// [`TryFromSexp`]: crate::TryFromSexp
/// [`IntoR`]: crate::IntoR
#[allow(non_camel_case_types)]
pub type mx_meth = unsafe extern "C" fn(data: *mut c_void, argc: i32, argv: *const SEXP) -> SEXP;

/// Base vtable present in all erased objects.
///
/// This vtable provides the minimal operations needed for any erased object:
/// - Destructor for cleanup when R garbage collects the wrapper
/// - Concrete type tag for type-safe downcasts
/// - Query function to retrieve interface vtables
///
/// ## Layout Guarantee
///
/// This type is `#[repr(C)]` and its layout is frozen. Fields will never
/// be reordered, and new fields will only be appended at the end.
///
/// ## Generated By
///
/// `miniextendr_module! { impl Trait for Type; }` emits a static instance of
/// this vtable for each wrapped type.
#[repr(C)]
pub struct mx_base_vtable {
    /// Destructor called when the R external pointer is garbage collected.
    ///
    /// Receives a pointer to the erased object (not the data pointer).
    /// Must deallocate the entire erased wrapper structure.
    ///
    /// # Safety
    ///
    /// - `ptr` must be a valid pointer to `mx_erased` allocated by this type's constructor
    /// - Must only be called once per object
    /// - Must be called on R's main thread (during GC finalization)
    pub drop: unsafe extern "C" fn(ptr: *mut mx_erased),

    /// Tag identifying the concrete type wrapped by this object.
    ///
    /// Used for type-safe downcasts: if `concrete_tag` matches the expected
    /// type's tag, the data pointer can be cast to that type.
    pub concrete_tag: mx_tag,

    /// Query function to retrieve interface vtables.
    ///
    /// Given a trait tag, returns a pointer to the vtable for that interface,
    /// or null if the type does not implement that trait.
    ///
    /// # Arguments
    ///
    /// * `ptr` - Pointer to the erased object
    /// * `trait_tag` - Tag identifying the requested trait interface
    ///
    /// # Returns
    ///
    /// - Non-null pointer to the trait's vtable if implemented
    /// - Null pointer if the trait is not implemented
    ///
    /// # Safety
    ///
    /// - `ptr` must be a valid pointer to `mx_erased`
    /// - The returned pointer (if non-null) must be cast to the correct vtable type
    pub query: unsafe extern "C" fn(ptr: *mut mx_erased, trait_tag: mx_tag) -> *const c_void,
}

/// Type-erased object header.
///
/// This is the common prefix of all erased objects, providing access to
/// the base vtable. The actual data follows this header in memory.
///
/// ## Memory Layout
///
/// ```text
/// ┌─────────────────────────────────────┐
/// │ mx_erased                           │
/// │   base: *const mx_base_vtable ──────┼──► static vtable
/// ├─────────────────────────────────────┤
/// │ (type-specific data follows...)     │
/// │   data: T                           │
/// │   interface_views: [...]            │
/// └─────────────────────────────────────┘
/// ```
///
/// ## Layout Guarantee
///
/// This type is `#[repr(C)]` and its layout is frozen. The `base` field
/// will always be at offset 0, and new fields will only be appended.
///
/// ## Generated By
///
/// `miniextendr_module! { impl Trait for Type; }` generates wrapper structs
/// that place `mx_erased` as the first field for proper layout.
#[repr(C)]
pub struct mx_erased {
    /// Pointer to the base vtable.
    ///
    /// This must point to a valid, static vtable for the lifetime of the object.
    /// The vtable is typically a `static` generated by `miniextendr_module!`.
    pub base: *const mx_base_vtable,
}

// =============================================================================
// Tag generation
// =============================================================================

/// FNV-1a 64-bit offset basis.
const FNV1A_64_OFFSET: u64 = 0xcbf29ce484222325;

/// FNV-1a 64-bit prime.
const FNV1A_64_PRIME: u64 = 0x00000100000001b3;

/// Compute FNV-1a 64-bit hash of a byte slice (const-compatible).
const fn fnv1a_64(bytes: &[u8], seed: u64) -> u64 {
    let mut hash = seed;
    let mut i = 0;
    while i < bytes.len() {
        hash ^= bytes[i] as u64;
        hash = hash.wrapping_mul(FNV1A_64_PRIME);
        i += 1;
    }
    hash
}

/// Create a new type tag from a string path.
///
/// This is a helper for generating deterministic tags from type/trait paths.
/// Uses FNV-1a hash to produce a 128-bit tag (two independent 64-bit hashes).
///
/// # Arguments
///
/// * `path` - Fully-qualified path like `"mypackage::MyType"` or `"mypackage::Foo"`
///
/// # Returns
///
/// A deterministic [`mx_tag`] for the given path.
///
/// # Example
///
/// ```
/// use miniextendr_api::abi::mx_tag_from_path;
///
/// const TAG_FOO: miniextendr_api::abi::mx_tag = mx_tag_from_path("mypackage::Foo");
/// const TAG_BAR: miniextendr_api::abi::mx_tag = mx_tag_from_path("mypackage::Bar");
///
/// // Same path produces same tag
/// assert_eq!(TAG_FOO, mx_tag_from_path("mypackage::Foo"));
///
/// // Different paths produce different tags
/// assert_ne!(TAG_FOO, TAG_BAR);
/// ```
///
/// # Note
///
/// This function is `const` to enable compile-time tag generation.
/// The hash is deterministic across compilations.
#[inline]
pub const fn mx_tag_from_path(path: &str) -> mx_tag {
    let bytes = path.as_bytes();
    // Use different seeds for lo and hi to get independent hash values
    let lo = fnv1a_64(bytes, FNV1A_64_OFFSET);
    // XOR with a different constant for the second hash to avoid correlation
    let hi = fnv1a_64(bytes, FNV1A_64_OFFSET ^ 0x5555555555555555);
    mx_tag::new(lo, hi)
}

#[cfg(test)]
mod tests;
